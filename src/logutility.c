#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <errno.h>
#include <signal.h>
#include <stdarg.h>
#include <string.h>
#include <queue>
#include <string>

#include "logutility.h"
#include "config.h"

#define NSEC_PER_SEC       1000000000 /* Do not change.Nanosecs per second */
#define MSEC_TO_NSEC       1000000    /* Do not change.Used to convert */
#define SIG                SIGUSR1    /* Signal generated by timer and..
                                       * caught by consumer thread to flush
                                       */

/* Message tag for LOG Messages*/
const char * DM_ERROR_MSG =   "<DM_LOG_ERROR>   :";
const char * DM_WARNING_MSG = "<DM_LOG_WARNING> :";
const char * DM_TRACE_MSG =   "<DM_LOG_TRACE>   :";
const char * DM_INFO_MSG =    "<DM_LOG_INFO>    :";


/* Message queue to hold all log messages*/
static std::queue<char*> logQueue; 

/* mutex for locking logQueue*/
static pthread_mutex_t     queueMutex = PTHREAD_MUTEX_INITIALIZER;

static FILE *fp;
static pthread_t consumer_t;


/*Function Prototypes for logutility.c */
static int createThread(pthread_t *thread,pthread_attr_t *attr, 
                        void *(*start_routine) (void *));
static int openLogFile();
static void * consumer(void *arg);
static void flushQueue();
static int startTimerRep(timer_t *timer, unsigned long time);
static int createTimer(timer_t *timer, int signo);
/*--Function Prototypes--*/


/* 
 * Name        : createTimer
 * 
 * Description : Creates a new timer which will generate a signal of type signo
 *
 * Arguments   : timer(timer_t)  - Timer struct
 *               signo(int)      - Signal to be generated
 *
 * Returns     : On Success - return 0
 *             : On Failure - return 1  
 */

static int createTimer(timer_t *timer, int signo)
{
    struct sigevent sev;

    /* Create the timer */
    sev.sigev_notify = SIGEV_SIGNAL;
    sev.sigev_value.sival_ptr = timer;

    /* Set signal number to signo */
    sev.sigev_signo = signo;

    if (timer_create(CLOCK_REALTIME, &sev, timer) == -1) 
    {
        fprintf(stderr,"%s\n", strerror(errno));
        return 1;
    }

    return 0;
}


/* 
 * Name        : startTimerRep
 * 
 * Description : Starts the timer to generate signal defined in timer struct
 *
 * Arguments   : timer(timer_t)            - Timer struct
 *               time (unsigned long)      - Interval of timer in Milliseconds 
 *
 * Returns     : On Success - return 0
 *             : On Failure - return 1  
 */

static int startTimerRep(timer_t *timer, unsigned long time)
{
    int ret;
    struct itimerspec its;

    if (!timer) 
    {
        return 1;
    }

    /* Set timer to generate signals after every time milliseconds*/
    its.it_value.tv_sec =  (time * MSEC_TO_NSEC)/ NSEC_PER_SEC;
    its.it_value.tv_nsec = (time * MSEC_TO_NSEC)% NSEC_PER_SEC;

    its.it_interval.tv_sec = its.it_value.tv_sec;
    its.it_interval.tv_nsec = its.it_value.tv_nsec;

    ret = timer_settime(*timer, 0, &its, NULL);

    return ret;
}


/* 
 * Name        : flushQueue
 * 
 * Description : Locks queue and flushes to file and/or console till not empty
 *
 * Arguments   : None
 *
 * Returns     : void
 */
static void flushQueue()
{
	pthread_mutex_lock(&queueMutex);
    /*While queue is not empty, print messages*/
    while(!logQueue.empty())
    {
        char *str = logQueue.front(); 
	    logQueue.pop();
        if(LOG_TO_FILE == 1)
        {
            fprintf(fp,"%s\n",str);
        }
        if(LOG_TO_CONSOLE == 1)
            printf("%s\n",str);    
    }
    /*Flush to disk after emptying queue to reduce overhead*/
    fflush(fp);	
    pthread_mutex_unlock(&queueMutex);	    
}


/* 
 * Name        : consumer
 * 
 * Description : Consumer thread which consumes log messages from log queue. 
 *               This thread uses sigwaitinfo() to wait on signal generated by
 *               timer or when DM_LOG_ERROR message arrives. Once signal is 
 *               received, it calls the flush queue function to print messages
 *                  
 *
 * Arguments   : This implementation does not take any arguments 
 *
 * Returns     : void
 */
static void * consumer(void *arg)
{
    sigset_t waitset;
    siginfo_t info;

    int result;
    /* Add SIG to waitset for sigwaitinfo to catch */
    sigaddset(&waitset, SIG);

    while(1)
    {
        /* 
         * Wait till signal is received from timer or 
         * manually when DM_LOG_ERROR is received.
         * Flush queue when signal received
         */        
        result = sigwaitinfo( &waitset, &info );
        if( result == SIG )
        {
            flushQueue();
        }
        else
        {
            if(errno == EINTR) continue;
            fprintf( stderr,"sigwait() function failed error number %d\n", 
                     errno );
        }

    }
    return NULL;
}


/* 
 * Name        : openLogFile
 * 
 * Description : Creates a new log file with current timestap as its name in 
 *               current directory if logging is enabled.  
 *
 * Arguments   : None 
 *
 * Returns     : On Success - return 0
 *             : On Failure - return 1  
 */
static int openLogFile()
{
    if(LOG_TO_FILE == 1)
    {
        time_t t = time(NULL);
	    struct tm tm= *localtime(&t);	
        std::string buffer;
        /*Create buffer with timestap to be set as filename of log file*/
        sprintf((char*)buffer.c_str(),"%d-%d-%d_%d-%d-%d.txt",tm.tm_mon + 1, 
                                                              tm.tm_mday, 
                                                              tm.tm_year + 1900, 
                                                              tm.tm_hour, 
                                                              tm.tm_min, 
                                                              tm.tm_sec);

    	fp = fopen(buffer.c_str(),"w");
	    if(!fp)
        {
	        fprintf(stderr,"Failed to open log file: %s\n", strerror(errno));
               return 1;   
        }
    }
    return 0;
}


/* 
 * Name        : createThread
 * 
 * Description : Wrapper function for creating threads
 *
 * Arguments   : thread(pthread_t)       - pthread_t struct of new thread 
 *               attr (pthread_attr_t)   - Attributes of new thread
 *               start_routine           - Thread routine to be started 
 *
 * Returns     : On Success - return 0
 *             : On Failure - return 1  
 */
static int createThread(pthread_t *thread,pthread_attr_t *attr, 
                        void *(*start_routine) (void *))
{
    
    /* Init thread with attributes */    
    if(pthread_attr_init(attr))
    {
	    fprintf(stderr,"Failed to init logger thread: %s\n", strerror(errno));
        return INIT_LOGGER_FAILED;
    }    
    
    /* Create thread */    
    if(pthread_create(thread, attr,start_routine, NULL))
    {
	    fprintf(stderr,"Failed to create logger thread: %s\n", strerror(errno));
        return INIT_LOGGER_FAILED;
    }

    /* Detach thread */
    if(pthread_detach(*thread))
    {
	    fprintf(stderr,"Failed to detach thread: %s\n", strerror(errno));
        return INIT_LOGGER_FAILED;
    }

    return INIT_LOGGER_OK; 
}

/* 
 * Name        : initLogger
 * 
 * Description : This function must be called by client code before using
 *               DMLog() for logging. 
 *               initLogger initializes all necessary factors required for 
 *               logging like: 
 *                 1) Opening log file, if logging is enabled
 *                 2) Create consumer thread which prints messages from queue
 *                 3) Set up signal waitset for consumer thread to wait on 
 *                     required signal
 *                 4) Call Create timer for generating signals
 *                 5) Call Start timer to start generating signals
 *              
 *
 * Arguments   : None 
 *
 * Returns     : On Success - return INIT_LOGGER_OK
 *             : On Failure - return INIT_LOGGER_FAILED
 */
int initLogger()
{    
    
    timer_t timerid;
    if(LOG_TO_FILE == 1)
    {
        if(openLogFile())
            return INIT_LOGGER_FAILED;
    }

    pthread_attr_t attr;
    
    /* 
     * Create waitset for sigwait info to wait on and add SIG to this set
     * call pthread_sigmask which is similar to sigprocmask for a pthread
     */
    sigset_t waitset;
    sigemptyset(&waitset);
    sigaddset( &waitset, SIG);
    pthread_sigmask(SIG_BLOCK, &waitset, NULL);

    /*
     * Create Consumer thread for consuming log messages 
     * Consumer thread waits on timer and manually generated signals
     * to print messages from log queue
     */

    if(createThread(&consumer_t,&attr,&consumer))
        return INIT_LOGGER_FAILED;

    /* Create timer which generate SIG signal */
    if(createTimer(&timerid,SIG))
        return INIT_LOGGER_FAILED;

    /* Start Timer to begin generating signals */
    if(startTimerRep(&timerid,TIMER_MS))
        return INIT_LOGGER_FAILED;

    return INIT_LOGGER_OK;
}


/* 
 * Name        : DMLog
 * 
 * Description : This function is used my client applications to log messages 
 *               to file and/or console. initLogger() function MUST be called
 *               before this function is used. 
 *               This function builds to final log message which is to be 
 *               printed by making using of va_list and vsprintf.
 *               All incoming messages are pushed to log Queue. 
 *               If DM_LOG_ERROR message is received, consumer thread is 
 *               signalled to flush queue to print DM_LOG_ERROR message as
 *               soon as possible
 *                  
 *
 * Arguments   : This implementation does not take any arguments
 *
 * Returns     : void
 */
void DMLog(DMLogLevel logLevel, char *format, ...)
{
    va_list arglist;
    std::string tempstr;
    std::string logMsg;

    switch(logLevel)    
    {

	    case DM_LOG_ERROR:
                tempstr.append(DM_ERROR_MSG);
                break;

        case DM_LOG_WARNING:
                tempstr.append(DM_WARNING_MSG);
                break; 

        case DM_LOG_TRACE:
                tempstr.append(DM_TRACE_MSG);
                break;		

        case DM_LOG_INFO:
                tempstr.append(DM_INFO_MSG);
                break;

	    default:
		        break;
    }    

    tempstr.append(format);
    /* 
     * Use vsprintf to compose formatted string
     * Store formatted string in tempstr
     */
    va_start( arglist, (char*) tempstr.c_str());
    vsprintf( (char*) logMsg.c_str(),(char*) tempstr.c_str(), arglist);
    va_end( arglist );

    /* 
     * Append tempstr to logMsg making it complete, ready 
     * to be pushed to queue
     */
  	

    /* Push formatted message to log Queue */
    pthread_mutex_lock(&queueMutex);
    logQueue.push((char*) logMsg.c_str());   
    pthread_mutex_unlock(&queueMutex);

    //printf("LOG MESSAGE CREATED IS: %s\n",(char*)logMsg.c_str());

    /*
     * If DM_LOG_ERROR message, signal consume thread 
     * to flush the queue and process DM_LOG_ERROR 
     * message immediately
     */
    if(logLevel == DM_LOG_ERROR)
    {
        if(pthread_kill(consumer_t,SIG))
            fprintf(stderr,"PTHREAD_KILL FAILED\n");
    }
}

